import * as fs from 'fs/promises';
import * as path from 'path';
import camelCase from 'camelcase';
import svg2elm from 'svg2elm';
import * as svgo from 'svgo';

const svgFolder = '../spor-icon/svg';
const targetFolder = './src/Spor/Icon';

async function generateSvgs() {
    await cleanAndsetupFolders()

    (await fs.readdir(svgFolder))
        .map((folderName) => {
            return {
                name: camelCase(folderName, { pascalCase: true }),
                path: path.join(svgFolder, folderName)
            };
        }).map(async (module) => {
            const svgPromises = (await fs.readdir(module.path))
                .filter((fileName) => fileName.endsWith('.svg'))
                .map(async (fileName) => {
                    const filePath = path.join(module.path, fileName);

                    const svg = await fs.readFile(filePath, { encoding: 'utf-8' });
                    const fileNameAsParts = parseFileName(fileName)
                    const optimizedSvg = svgo.optimize(svg);
                    const svgWithoutDefaultFill = removeDefaultFillColor(optimizedSvg.data)
                    const elmName = camelCase(fileNameAsParts.name);
                    const internalName = elmName + "_";
                    const elmSvg = await svg2elm.generateSvgFunction(internalName, svgWithoutDefaultFill);
                    const actualElmName = elmSvg.split(':')[0].trim();

                    return {
                        internalName,
                        name: actualElmName,
                        impl: elmSvg,
                        size: fileNameAsParts.size
                    };
                });

            const svgs = await Promise.all(svgPromises);
            const svgNames = svgs.map((svg) => svg.name);
            const svgImpls = svgs.map((svg) => svg.impl);
            const uniqueIconSizes = new Set([...svgs.map(svg => svg.size)])

            const moduleHeader = generateModuleHeader(module.name, svgNames);
            const src = [moduleHeader].concat(svgImpls)
                .join('\n\n\n{-|-}\n');

            return {
                ...module,
                src: src
            };
        }).forEach(async (modulePromise) => {
            const module = await modulePromise;

            const targetFile = path.join(targetFolder, `${module.name}.elm`);

            await fs.writeFile(targetFile, module.src);
        });
}

// File names are structured as "name-[fill|stroke]-[size]x[size].svg"
function parseFileName(fileName) {
    const [iconName, fillType, size] = fileName.split("-")
    return {
        iconName,
        fillType,
        size
    }
}

async function cleanAndsetupFolders() {
    await fs.rm('./src', { recursive: true, force: true });
    await fs.mkdir(targetFolder, { recursive: true });
}

// Default fill color is set on parent with Elm, to allow differentiation on backgrounds, etc.
function removeDefaultFillColor(svgString) {
    return svgString.replace('fill="#2B2B2C"', "")
}

function generateIconVariants(iconNames) {
    const [firstIcon, ...rest] = iconNames.map(icon => camelCase(icon, { pascalCase: true }))
    return `
    {-| -}
    type IconVariant =
        ${firstIcon}
        ${rest.map((iconName => `| ${iconName}\n`))}
    `
}


// Generates the Size-type from a list of unique icon sizes. This list is generated by parsing SVG file names.
function generateSizes(uniqueIconSizes) {
    const [firstSize, ...rest] = uniqueIconSizes.map(size => camelCase(size, { pascalCase: true }))
    return` 
    {-| -}
    type Size =
        ${firstSize}
        ${rest.map(size => `| ${size}\n`)}
    `
}

function generateToHtmlCase(icons) {
    return `
    case iconConfig.icon of
        ${icons.map(icon => `${camelCase(icon, { pascalCase: true })} ->
            ${icon} iconConfig
        `)}
    `
}


// Generates the function for each SVG with height, width, and fill or stroke. 
function generateBasicCase(iconName, iconNameInternal) {
return`
{-| -}
${iconName} : IconConfig -> Svg.Svg msg
${iconName} iconConfig =
    let
        attributes =
            [ attribute "width" iconConfig.size, attribute "height" iconConfig.size ]
            
    in
    case iconConfig.variant of
        Fill ->
            ${iconNameInternal} (attribute "fill" iconConfig.color) :: attributes
        
        Stroke ->
            ${iconNameInternal} (attribute "stroke" iconConfig.color) :: attributes

`
}


function generateModuleHeader(moduleName, svgNames, sizes) {
    const svgNameExportStr = svgNames.join(', ');

    return `module Spor.Icon.${moduleName} exposing (${svgNameExportStr})

{-| ${moduleName} icons

@docs ${svgNameExportStr}

-}

import Svg
import VirtualDom exposing (Attribute, attribute)


${generateIconVariants(svgNames)}

${generateSizes(sizes)}

{-| -}
type FillType
    = Fill
    | Stroke


{-| -}
type IconConfig
    = IconConfig
        { icon : IconVariant
        , size : Size
        , variant : FillType
        , color : String
        }


{-| -}
icon : Size -> FillType -> IconVariant -> IconConfig
icon size fillType iconVariant =
        IconConfig { 
            icon = iconVariant
            , size = size
            , variant = fillType
            , color = "#2B2B2C"
        }

{-| -}
withColor : String -> IconConfig -> IconConfig
withColor color config =
        { config | color = color }
 

{-| -}
toHtml : IconConfig -> Html msg
toHtml iconConfig =
    ${generateToHtmlCase(svgNames)}


${svgNames.map(svgName => generateBasicCase(svgName, svgName + "_") +"\n\n")}
`;
}

generateSvgs();
