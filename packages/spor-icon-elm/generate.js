import * as fs from 'fs/promises';
import * as path from 'path';
import camelCase from 'camelcase';
import svg2elm from 'svg2elm';
import * as svgo from 'svgo';

const svgFolder = '../spor-icon/svg';
const targetFolder = './src/Spor/Icon';

const groupBy = (xs, key) => {
    return xs.reduce(function(rv, x) {
      (rv[x[key]] = rv[x[key]] || []).push(x);
      return rv;
    }, {});
  };

const maxBy = (items, field) => items.reduce((seed,item) => { return (seed && seed[field] > item[field]) ? seed : item; },null);

async function generateSvgs() {
    await fs.rm('./src', { recursive: true, force: true });
    await fs.mkdir(targetFolder, { recursive: true });

    const svgs = (await fs.readdir(svgFolder))
        .map((folderName) => {
            return {
                name: camelCase(folderName, { pascalCase: true }),
                path: path.join(svgFolder, folderName)
            };
        }).map(async (module) => {
            const svgPromises = (await fs.readdir(module.path))
                .filter((fileName) => fileName.endsWith('.svg'))
                .map(async (fileName) => {
                    const filePath = path.join(module.path, fileName);

                    const svg = await fs.readFile(filePath, { encoding: 'utf-8' });
                    const fileNameAsParts = parseFileName(fileName)
                    const optimizedSvg = svgo.optimize(svg);
                    const svgWithoutHardcodedSize = removeHardcodedSize(optimizedSvg.data)
                    const svgWithoutDefaultFill = removeDefaultFillColor(svgWithoutHardcodedSize)
                    const elmName = camelCase(fileNameAsParts.iconName);
                    const internalName = elmName + "_"
                    const elmSvg = await svg2elm.generateSvgFunction(elmName, svgWithoutDefaultFill);
                    const elmSvgInternal = injectUnderscoreToImpl(elmSvg, elmName)

                    return {
                        internalName,
                        name: elmName,
                        impl: elmSvgInternal,
                        size: fileNameAsParts.size,
                        sizeAsInt : Number(fileNameAsParts.size)
                    };
                });

            const svgs = await Promise.all(svgPromises);
            return svgs
        })
    await Promise.all(svgs).then(svgs => {
    const groupedSvgs = groupBy(svgs.flat(), "name")
    const svgsWithMaxSizeOnly = Object.values(groupedSvgs).map(group => maxBy(group, "sizeAsInt"))
    const svgNames = svgsWithMaxSizeOnly.map((svg) => svg.name);
    const svgImpls = svgsWithMaxSizeOnly.map((svg) => svg.impl)
    const uniqueIconSizes = Array.from(new Set([...svgs.flat().map(svg => svg.size)]))

    const moduleHeader = generateModuleHeader("Icons", svgNames, uniqueIconSizes);
    const src = [moduleHeader].concat(svgImpls)
        .join('\n\n\n{-|-}\n');

    const targetFile = path.join(targetFolder, `Icons.elm`);

    fs.writeFile(targetFile, src);
    })
    
}

// File names are structured as "name-[fill|stroke]-[size]x[size].svg"
function parseFileName(fileName) {
    const [iconName, fillType, size] = fileName.split("-")
    const sizeAsNumber = size ? size.split("x")[0] : "24"
    const fillTypeWithDefault = fillType === "outline" || fillType === "fill" ? fillType : "outline"
    const sizeWithDefault = isNaN(sizeAsNumber) ? "24" : sizeAsNumber
    return {
        iconName,
        fillType: fillTypeWithDefault,
        size: sizeWithDefault
    }
}

function injectUnderscoreToImpl(implString, name) {
    return implString.replaceAll(name, name + "_")
}

// Default fill color is set on parent with Elm, to allow differentiation on backgrounds, etc.
function removeDefaultFillColor(svgString) {
    return svgString.replaceAll('fill="#2B2B2C"', "")
}

function removeHardcodedSize(svgString) {
    return svgString.replace(/width="\d{2}"/,"").replace(/height="\d{2}"/, "")
}

function generateIconVariants(iconNames) {
    const [firstIcon, ...rest] = iconNames.map(icon => camelCase(icon, { pascalCase: true }))
    return `
{-| -}
type IconVariant =
    ${firstIcon}
    ${rest.map(iconName => `| ${iconName}`).join("\n    ")}
    `
}


// Generates the Size-type from a list of unique icon sizes. This list is generated by parsing SVG file names.
function generateSizes(uniqueIconSizes) {
    const [firstSize, ...rest] = (uniqueIconSizes).map(size => camelCase(size, { pascalCase: true }))
    return` 
{-| -}
type Size =
    Size${firstSize}
    ${rest.map(size => `| Size${size}`).join("\n    ")}
    `
}

/*

type Size =
    Size1
    | Size2
    | Size3

*/

function generateToHtmlCase(icons) {
    return `
{-| -}
toHtml : IconConfig -> Html msg
toHtml iconConfig =
    case iconConfig.icon of
        ${icons.map(icon => `${camelCase(icon, { pascalCase: true })} ->
            ${icon} iconConfig
        `).join("\n        ")}
    `
}


// Generates the function for each SVG with height, width, and fill or stroke. 
function generateBasicCase(iconName, iconNameInternal) {
return`
{-| -}
${iconName} : IconConfig -> Svg.Svg msg
${iconName} iconConfig =
    let
        attributes =
            [ attribute "width" iconConfig.size, attribute "height" iconConfig.size ]
            
    in
    case iconConfig.variant of
        Fill ->
            ${iconNameInternal} (attribute "fill" iconConfig.color) :: attributes
        
        Stroke ->
            ${iconNameInternal} (attribute "stroke" iconConfig.color) :: attributes

`
}


function generateModuleHeader(moduleName, svgNames, sizes) {
    const svgNameExportStr = svgNames.join(', ');

    return `module Spor.Icon.${moduleName} exposing (toHtml, FillType(..), IconConfig, Size(..), IconVariant(..), icon, withColor)

{-| ${moduleName}

@docs toHtml, FillType(..), IconConfig, Size(..), IconVariant(..), icon, withColor

-}

import Svg
import VirtualDom exposing (Attribute, attribute)


${generateIconVariants(svgNames)}

${generateSizes(sizes)}

{-| -}
type FillType
    = Fill
    | Stroke


{-| -}
type IconConfig
    = IconConfig
        { icon : IconVariant
        , size : Size
        , variant : FillType
        , color : String
        }


{-| -}
icon : Size -> FillType -> IconVariant -> IconConfig
icon size fillType iconVariant =
        IconConfig { 
            icon = iconVariant
            , size = size
            , variant = fillType
            , color = "#2B2B2C"
        }

{-| -}
withColor : String -> IconConfig -> IconConfig
withColor color config =
        { config | color = color }
 


${generateToHtmlCase(svgNames)}


${svgNames.map(svgName => generateBasicCase(svgName, svgName + "_") +"\n\n")}
`;
}

generateSvgs();
